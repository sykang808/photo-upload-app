"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.destroyStack = exports.makeBodyParameterAndUpload = exports.deployStack = void 0;
const cxapi = require("@aws-cdk/cx-api");
const chalk = require("chalk");
const fs = require("fs-extra");
const uuid = require("uuid");
const assets_1 = require("../assets");
const logging_1 = require("../logging");
const serialize_1 = require("../serialize");
const asset_manifest_builder_1 = require("../util/asset-manifest-builder");
const asset_publishing_1 = require("../util/asset-publishing");
const content_hash_1 = require("../util/content-hash");
const evaluate_cloudformation_template_1 = require("./evaluate-cloudformation-template");
const hotswap_deployments_1 = require("./hotswap-deployments");
const common_1 = require("./hotswap/common");
const cloudformation_1 = require("./util/cloudformation");
const stack_activity_monitor_1 = require("./util/cloudformation/stack-activity-monitor");
const LARGE_TEMPLATE_SIZE_KB = 50;
async function deployStack(options) {
    const stackArtifact = options.stack;
    const stackEnv = options.resolvedEnvironment;
    options.sdk.appendCustomUserAgent(options.extraUserAgent);
    const cfn = options.sdk.cloudFormation();
    const deployName = options.deployName || stackArtifact.stackName;
    let cloudFormationStack = await cloudformation_1.CloudFormationStack.lookup(cfn, deployName);
    if (cloudFormationStack.stackStatus.isCreationFailure) {
        logging_1.debug(`Found existing stack ${deployName} that had previously failed creation. Deleting it before attempting to re-create it.`);
        await cfn.deleteStack({ StackName: deployName }).promise();
        const deletedStack = await cloudformation_1.waitForStackDelete(cfn, deployName);
        if (deletedStack && deletedStack.stackStatus.name !== 'DELETE_COMPLETE') {
            throw new Error(`Failed deleting stack ${deployName} that had previously failed creation (current state: ${deletedStack.stackStatus})`);
        }
        // Update variable to mark that the stack does not exist anymore, but avoid
        // doing an actual lookup in CloudFormation (which would be silly to do if
        // we just deleted it).
        cloudFormationStack = cloudformation_1.CloudFormationStack.doesNotExist(cfn, deployName);
    }
    // Detect "legacy" assets (which remain in the metadata) and publish them via
    // an ad-hoc asset manifest, while passing their locations via template
    // parameters.
    const legacyAssets = new asset_manifest_builder_1.AssetManifestBuilder();
    const assetParams = await assets_1.addMetadataAssetsToManifest(stackArtifact, legacyAssets, options.toolkitInfo, options.reuseAssets);
    const finalParameterValues = { ...options.parameters, ...assetParams };
    const templateParams = cloudformation_1.TemplateParameters.fromTemplate(stackArtifact.template);
    const stackParams = options.usePreviousParameters
        ? templateParams.updateExisting(finalParameterValues, cloudFormationStack.parameters)
        : templateParams.supplyAll(finalParameterValues);
    if (await canSkipDeploy(options, cloudFormationStack, stackParams.hasChanges(cloudFormationStack.parameters))) {
        logging_1.debug(`${deployName}: skipping deployment (use --force to override)`);
        // if we can skip deployment and we are performing a hotswap, let the user know
        // that no hotswap deployment happened
        if (options.hotswap) {
            logging_1.print(`\n ${common_1.ICON} %s\n`, chalk.bold('hotswap deployment skipped - no changes were detected (use --force to override)'));
        }
        return {
            noOp: true,
            outputs: cloudFormationStack.outputs,
            stackArn: cloudFormationStack.stackId,
        };
    }
    else {
        logging_1.debug(`${deployName}: deploying...`);
    }
    const bodyParameter = await makeBodyParameter(stackArtifact, options.resolvedEnvironment, legacyAssets, options.toolkitInfo, options.sdk, options.overrideTemplate);
    await asset_publishing_1.publishAssets(legacyAssets.toManifest(stackArtifact.assembly.directory), options.sdkProvider, stackEnv);
    if (options.hotswap) {
        // attempt to short-circuit the deployment if possible
        try {
            const hotswapDeploymentResult = await hotswap_deployments_1.tryHotswapDeployment(options.sdkProvider, assetParams, cloudFormationStack, stackArtifact);
            if (hotswapDeploymentResult) {
                return hotswapDeploymentResult;
            }
            logging_1.print('Could not perform a hotswap deployment, as the stack %s contains non-Asset changes', stackArtifact.displayName);
        }
        catch (e) {
            if (!(e instanceof evaluate_cloudformation_template_1.CfnEvaluationException)) {
                throw e;
            }
            logging_1.print('Could not perform a hotswap deployment, because the CloudFormation template could not be resolved: %s', e.message);
        }
        logging_1.print('Falling back to doing a full deployment');
    }
    // could not short-circuit the deployment, perform a full CFN deploy instead
    return prepareAndExecuteChangeSet(options, cloudFormationStack, stackArtifact, stackParams, bodyParameter);
}
exports.deployStack = deployStack;
async function prepareAndExecuteChangeSet(options, cloudFormationStack, stackArtifact, stackParams, bodyParameter) {
    var _a, _b, _c, _d;
    // if we got here, and hotswap is enabled, that means changes couldn't be hotswapped,
    // and we had to fall back on a full deployment. Note that fact in our User-Agent
    if (options.hotswap) {
        options.sdk.appendCustomUserAgent('cdk-hotswap/fallback');
    }
    const cfn = options.sdk.cloudFormation();
    const deployName = (_a = options.deployName) !== null && _a !== void 0 ? _a : stackArtifact.stackName;
    const changeSetName = (_b = options.changeSetName) !== null && _b !== void 0 ? _b : 'cdk-deploy-change-set';
    if (cloudFormationStack.exists) {
        //Delete any existing change sets generated by CDK since change set names must be unique.
        //The delete request is successful as long as the stack exists (even if the change set does not exist).
        logging_1.debug(`Removing existing change set with name ${changeSetName} if it exists`);
        await cfn.deleteChangeSet({ StackName: deployName, ChangeSetName: changeSetName }).promise();
    }
    const update = cloudFormationStack.exists && cloudFormationStack.stackStatus.name !== 'REVIEW_IN_PROGRESS';
    logging_1.debug(`Attempting to create ChangeSet with name ${changeSetName} to ${update ? 'update' : 'create'} stack ${deployName}`);
    logging_1.print('%s: creating CloudFormation changeset...', chalk.bold(deployName));
    const executionId = uuid.v4();
    const changeSet = await cfn.createChangeSet({
        StackName: deployName,
        ChangeSetName: changeSetName,
        ChangeSetType: options.resourcesToImport ? 'IMPORT' : update ? 'UPDATE' : 'CREATE',
        ResourcesToImport: options.resourcesToImport,
        Description: `CDK Changeset for execution ${executionId}`,
        TemplateBody: bodyParameter.TemplateBody,
        TemplateURL: bodyParameter.TemplateURL,
        Parameters: stackParams.apiParameters,
        RoleARN: options.roleArn,
        NotificationARNs: options.notificationArns,
        Capabilities: ['CAPABILITY_IAM', 'CAPABILITY_NAMED_IAM', 'CAPABILITY_AUTO_EXPAND'],
        Tags: options.tags,
    }).promise();
    logging_1.debug('Initiated creation of changeset: %s; waiting for it to finish creating...', changeSet.Id);
    const changeSetDescription = await cloudformation_1.waitForChangeSet(cfn, deployName, changeSetName);
    // Update termination protection only if it has changed.
    const terminationProtection = (_c = stackArtifact.terminationProtection) !== null && _c !== void 0 ? _c : false;
    if (!!cloudFormationStack.terminationProtection !== terminationProtection) {
        logging_1.debug('Updating termination protection from %s to %s for stack %s', cloudFormationStack.terminationProtection, terminationProtection, deployName);
        await cfn.updateTerminationProtection({
            StackName: deployName,
            EnableTerminationProtection: terminationProtection,
        }).promise();
        logging_1.debug('Termination protection updated to %s for stack %s', terminationProtection, deployName);
    }
    if (cloudformation_1.changeSetHasNoChanges(changeSetDescription)) {
        logging_1.debug('No changes are to be performed on %s.', deployName);
        if (options.execute) {
            logging_1.debug('Deleting empty change set %s', changeSet.Id);
            await cfn.deleteChangeSet({ StackName: deployName, ChangeSetName: changeSetName }).promise();
        }
        return { noOp: true, outputs: cloudFormationStack.outputs, stackArn: changeSet.StackId };
    }
    const execute = options.execute === undefined ? true : options.execute;
    if (execute) {
        logging_1.debug('Initiating execution of changeset %s on stack %s', changeSet.Id, deployName);
        const shouldDisableRollback = options.rollback === false;
        // Do a bit of contortions to only pass the `DisableRollback` flag if it's true. That way,
        // CloudFormation won't balk at the unrecognized option in regions where the feature is not available yet.
        const disableRollback = shouldDisableRollback ? { DisableRollback: true } : undefined;
        await cfn.executeChangeSet({ StackName: deployName, ChangeSetName: changeSetName, ...disableRollback }).promise();
        // eslint-disable-next-line max-len
        const changeSetLength = ((_d = changeSetDescription.Changes) !== null && _d !== void 0 ? _d : []).length;
        const monitor = options.quiet ? undefined : stack_activity_monitor_1.StackActivityMonitor.withDefaultPrinter(cfn, deployName, stackArtifact, {
            // +1 for the extra event emitted from updates.
            resourcesTotal: cloudFormationStack.exists ? changeSetLength + 1 : changeSetLength,
            progress: options.progress,
            changeSetCreationTime: changeSetDescription.CreationTime,
        }).start();
        logging_1.debug('Execution of changeset %s on stack %s has started; waiting for the update to complete...', changeSet.Id, deployName);
        try {
            const finalStack = await cloudformation_1.waitForStackDeploy(cfn, deployName);
            // This shouldn't really happen, but catch it anyway. You never know.
            if (!finalStack) {
                throw new Error('Stack deploy failed (the stack disappeared while we were deploying it)');
            }
            cloudFormationStack = finalStack;
        }
        finally {
            await (monitor === null || monitor === void 0 ? void 0 : monitor.stop());
        }
        logging_1.debug('Stack %s has completed updating', deployName);
    }
    else {
        logging_1.print('Changeset %s created and waiting in review for manual execution (--no-execute)', changeSet.Id);
    }
    return { noOp: false, outputs: cloudFormationStack.outputs, stackArn: changeSet.StackId };
}
/**
 * Prepares the body parameter for +CreateChangeSet+.
 *
 * If the template is small enough to be inlined into the API call, just return
 * it immediately.
 *
 * Otherwise, add it to the asset manifest to get uploaded to the staging
 * bucket and return its coordinates. If there is no staging bucket, an error
 * is thrown.
 *
 * @param stack     the synthesized stack that provides the CloudFormation template
 * @param toolkitInfo information about the toolkit stack
 */
async function makeBodyParameter(stack, resolvedEnvironment, assetManifest, toolkitInfo, sdk, overrideTemplate) {
    // If the template has already been uploaded to S3, just use it from there.
    if (stack.stackTemplateAssetObjectUrl && !overrideTemplate) {
        return { TemplateURL: restUrlFromManifest(stack.stackTemplateAssetObjectUrl, resolvedEnvironment, sdk) };
    }
    // Otherwise, pass via API call (if small) or upload here (if large)
    const templateJson = serialize_1.toYAML(overrideTemplate !== null && overrideTemplate !== void 0 ? overrideTemplate : stack.template);
    if (templateJson.length <= LARGE_TEMPLATE_SIZE_KB * 1024) {
        return { TemplateBody: templateJson };
    }
    if (!toolkitInfo.found) {
        logging_1.error(`The template for stack "${stack.displayName}" is ${Math.round(templateJson.length / 1024)}KiB. ` +
            `Templates larger than ${LARGE_TEMPLATE_SIZE_KB}KiB must be uploaded to S3.\n` +
            'Run the following command in order to setup an S3 bucket in this environment, and then re-deploy:\n\n', chalk.blue(`\t$ cdk bootstrap ${resolvedEnvironment.name}\n`));
        throw new Error('Template too large to deploy ("cdk bootstrap" is required)');
    }
    const templateHash = content_hash_1.contentHash(templateJson);
    const key = `cdk/${stack.id}/${templateHash}.yml`;
    let templateFile = stack.templateFile;
    if (overrideTemplate) {
        // Add a variant of this template
        templateFile = `${stack.templateFile}-${templateHash}.yaml`;
        await fs.writeFile(templateFile, templateJson, { encoding: 'utf-8' });
    }
    assetManifest.addFileAsset(templateHash, {
        path: templateFile,
    }, {
        bucketName: toolkitInfo.bucketName,
        objectKey: key,
    });
    const templateURL = `${toolkitInfo.bucketUrl}/${key}`;
    logging_1.debug('Storing template in S3 at:', templateURL);
    return { TemplateURL: templateURL };
}
/**
 * Prepare a body parameter for CFN, performing the upload
 *
 * Return it as-is if it is small enough to pass in the API call,
 * upload to S3 and return the coordinates if it is not.
 */
async function makeBodyParameterAndUpload(stack, resolvedEnvironment, toolkitInfo, sdkProvider, sdk, overrideTemplate) {
    // We don't have access to the actual asset manifest here, so pretend that the
    // stack doesn't have a pre-published URL.
    const forceUploadStack = Object.create(stack, {
        stackTemplateAssetObjectUrl: { value: undefined },
    });
    const builder = new asset_manifest_builder_1.AssetManifestBuilder();
    const bodyparam = await makeBodyParameter(forceUploadStack, resolvedEnvironment, builder, toolkitInfo, sdk, overrideTemplate);
    const manifest = builder.toManifest(stack.assembly.directory);
    await asset_publishing_1.publishAssets(manifest, sdkProvider, resolvedEnvironment, { quiet: true });
    return bodyparam;
}
exports.makeBodyParameterAndUpload = makeBodyParameterAndUpload;
async function destroyStack(options) {
    const deployName = options.deployName || options.stack.stackName;
    const cfn = options.sdk.cloudFormation();
    const currentStack = await cloudformation_1.CloudFormationStack.lookup(cfn, deployName);
    if (!currentStack.exists) {
        return;
    }
    const monitor = options.quiet ? undefined : stack_activity_monitor_1.StackActivityMonitor.withDefaultPrinter(cfn, deployName, options.stack).start();
    try {
        await cfn.deleteStack({ StackName: deployName, RoleARN: options.roleArn }).promise();
        const destroyedStack = await cloudformation_1.waitForStackDelete(cfn, deployName);
        if (destroyedStack && destroyedStack.stackStatus.name !== 'DELETE_COMPLETE') {
            throw new Error(`Failed to destroy ${deployName}: ${destroyedStack.stackStatus}`);
        }
    }
    finally {
        if (monitor) {
            await monitor.stop();
        }
    }
}
exports.destroyStack = destroyStack;
/**
 * Checks whether we can skip deployment
 *
 * We do this in a complicated way by preprocessing (instead of just
 * looking at the changeset), because if there are nested stacks involved
 * the changeset will always show the nested stacks as needing to be
 * updated, and the deployment will take a long time to in effect not
 * do anything.
 */
async function canSkipDeploy(deployStackOptions, cloudFormationStack, parameterChanges) {
    var _a;
    const deployName = deployStackOptions.deployName || deployStackOptions.stack.stackName;
    logging_1.debug(`${deployName}: checking if we can skip deploy`);
    // Forced deploy
    if (deployStackOptions.force) {
        logging_1.debug(`${deployName}: forced deployment`);
        return false;
    }
    // Creating changeset only (default true), never skip
    if (deployStackOptions.execute === false) {
        logging_1.debug(`${deployName}: --no-execute, always creating change set`);
        return false;
    }
    // No existing stack
    if (!cloudFormationStack.exists) {
        logging_1.debug(`${deployName}: no existing stack`);
        return false;
    }
    // Template has changed (assets taken into account here)
    if (JSON.stringify(deployStackOptions.stack.template) !== JSON.stringify(await cloudFormationStack.template())) {
        logging_1.debug(`${deployName}: template has changed`);
        return false;
    }
    // Tags have changed
    if (!compareTags(cloudFormationStack.tags, (_a = deployStackOptions.tags) !== null && _a !== void 0 ? _a : [])) {
        logging_1.debug(`${deployName}: tags have changed`);
        return false;
    }
    // Termination protection has been updated
    if (!!deployStackOptions.stack.terminationProtection !== !!cloudFormationStack.terminationProtection) {
        logging_1.debug(`${deployName}: termination protection has been updated`);
        return false;
    }
    // Parameters have changed
    if (parameterChanges) {
        if (parameterChanges === 'ssm') {
            logging_1.debug(`${deployName}: some parameters come from SSM so we have to assume they may have changed`);
        }
        else {
            logging_1.debug(`${deployName}: parameters have changed`);
        }
        return false;
    }
    // Existing stack is in a failed state
    if (cloudFormationStack.stackStatus.isFailure) {
        logging_1.debug(`${deployName}: stack is in a failure state`);
        return false;
    }
    // We can skip deploy
    return true;
}
/**
 * Compares two list of tags, returns true if identical.
 */
function compareTags(a, b) {
    if (a.length !== b.length) {
        return false;
    }
    for (const aTag of a) {
        const bTag = b.find(tag => tag.Key === aTag.Key);
        if (!bTag || bTag.Value !== aTag.Value) {
            return false;
        }
    }
    return true;
}
/**
 * Format an S3 URL in the manifest for use with CloudFormation
 *
 * Replaces environment placeholders (which this field may contain),
 * and reformats s3://.../... urls into S3 REST URLs (which CloudFormation
 * expects)
 */
function restUrlFromManifest(url, environment, sdk) {
    const doNotUseMarker = '**DONOTUSE**';
    // This URL may contain placeholders, so still substitute those.
    url = cxapi.EnvironmentPlaceholders.replace(url, {
        accountId: environment.account,
        region: environment.region,
        partition: doNotUseMarker,
    });
    // Yes, this is extremely crude, but we don't actually need this so I'm not inclined to spend
    // a lot of effort trying to thread the right value to this location.
    if (url.indexOf(doNotUseMarker) > -1) {
        throw new Error('Cannot use \'${AWS::Partition}\' in the \'stackTemplateAssetObjectUrl\' field');
    }
    const s3Url = url.match(/s3:\/\/([^/]+)\/(.*)$/);
    if (!s3Url) {
        return url;
    }
    // We need to pass an 'https://s3.REGION.amazonaws.com[.cn]/bucket/object' URL to CloudFormation, but we
    // got an 's3://bucket/object' URL instead. Construct the rest API URL here.
    const bucketName = s3Url[1];
    const objectKey = s3Url[2];
    const urlSuffix = sdk.getEndpointSuffix(environment.region);
    return `https://s3.${environment.region}.${urlSuffix}/${bucketName}/${objectKey}`;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVwbG95LXN0YWNrLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZGVwbG95LXN0YWNrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHlDQUF5QztBQUN6QywrQkFBK0I7QUFDL0IsK0JBQStCO0FBQy9CLDZCQUE2QjtBQUM3QixzQ0FBd0Q7QUFFeEQsd0NBQWlEO0FBQ2pELDRDQUFzQztBQUN0QywyRUFBc0U7QUFDdEUsK0RBQXlEO0FBQ3pELHVEQUFtRDtBQUVuRCx5RkFBNEU7QUFDNUUsK0RBQTZEO0FBQzdELDZDQUF3QztBQUV4QywwREFHK0I7QUFDL0IseUZBQTJHO0FBMkwzRyxNQUFNLHNCQUFzQixHQUFHLEVBQUUsQ0FBQztBQUUzQixLQUFLLFVBQVUsV0FBVyxDQUFDLE9BQTJCO0lBQzNELE1BQU0sYUFBYSxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUM7SUFFcEMsTUFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLG1CQUFtQixDQUFDO0lBRTdDLE9BQU8sQ0FBQyxHQUFHLENBQUMscUJBQXFCLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxDQUFDO0lBQzFELE1BQU0sR0FBRyxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsY0FBYyxFQUFFLENBQUM7SUFDekMsTUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLFVBQVUsSUFBSSxhQUFhLENBQUMsU0FBUyxDQUFDO0lBQ2pFLElBQUksbUJBQW1CLEdBQUcsTUFBTSxvQ0FBbUIsQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLFVBQVUsQ0FBQyxDQUFDO0lBRTVFLElBQUksbUJBQW1CLENBQUMsV0FBVyxDQUFDLGlCQUFpQixFQUFFO1FBQ3JELGVBQUssQ0FBQyx3QkFBd0IsVUFBVSxzRkFBc0YsQ0FBQyxDQUFDO1FBQ2hJLE1BQU0sR0FBRyxDQUFDLFdBQVcsQ0FBQyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQzNELE1BQU0sWUFBWSxHQUFH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RSxJQUFJLEdBQUcsQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUU7UUFDcEMsTUFBTSxJQUFJLEtBQUssQ0FBQywrRUFBK0UsQ0FBQyxDQUFDO0tBQ2xHO0lBRUQsTUFBTSxLQUFLLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO0lBQ2pELElBQUksQ0FBQyxLQUFLLEVBQUU7UUFBRSxPQUFPLEdBQUcsQ0FBQztLQUFFO0lBRTNCLHdHQUF3RztJQUN4Ryw0RUFBNEU7SUFDNUUsTUFBTSxVQUFVLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzVCLE1BQU0sU0FBUyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUUzQixNQUFNLFNBQVMsR0FBVyxHQUFHLENBQUMsaUJBQWlCLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3BFLE9BQU8sY0FBYyxXQUFXLENBQUMsTUFBTSxJQUFJLFNBQVMsSUFBSSxVQUFVLElBQUksU0FBUyxFQUFFLENBQUM7QUFDcEYsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgKiBhcyBjaGFsayBmcm9tICdjaGFsayc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgKiBhcyB1dWlkIGZyb20gJ3V1aWQnO1xuaW1wb3J0IHsgYWRkTWV0YWRhdGFBc3NldHNUb01hbmlmZXN0IH0gZnJvbSAnLi4vYXNzZXRzJztcbmltcG9ydCB7IFRhZyB9IGZyb20gJy4uL2Nkay10b29sa2l0JztcbmltcG9ydCB7IGRlYnVnLCBlcnJvciwgcHJpbnQgfSBmcm9tICcuLi9sb2dnaW5nJztcbmltcG9ydCB7IHRvWUFNTCB9IGZyb20gJy4uL3NlcmlhbGl6ZSc7XG5pbXBvcnQgeyBBc3NldE1hbmlmZXN0QnVpbGRlciB9IGZyb20gJy4uL3V0aWwvYXNzZXQtbWFuaWZlc3QtYnVpbGRlcic7XG5pbXBvcnQgeyBwdWJsaXNoQXNzZXRzIH0gZnJvbSAnLi4vdXRpbC9hc3NldC1wdWJsaXNoaW5nJztcbmltcG9ydCB7IGNvbnRlbnRIYXNoIH0gZnJvbSAnLi4vdXRpbC9jb250ZW50LWhhc2gnO1xuaW1wb3J0IHsgSVNESywgU2RrUHJvdmlkZXIgfSBmcm9tICcuL2F3cy1hdXRoJztcbmltcG9ydCB7IENmbkV2YWx1YXRpb25FeGNlcHRpb24gfSBmcm9tICcuL2V2YWx1YXRlLWNsb3VkZm9ybWF0aW9uLXRlbXBsYXRlJztcbmltcG9ydCB7IHRyeUhvdHN3YXBEZXBsb3ltZW50IH0gZnJvbSAnLi9ob3Rzd2FwLWRlcGxveW1lbnRzJztcbmltcG9ydCB7IElDT04gfSBmcm9tICcuL2hvdHN3YXAvY29tbW9uJztcbmltcG9ydCB7IFRvb2xraXRJbmZvIH0gZnJvbSAnLi90b29sa2l0LWluZm8nO1xuaW1wb3J0IHtcbiAgY2hhbmdlU2V0SGFzTm9DaGFuZ2VzLCBDbG91ZEZvcm1hdGlvblN0YWNrLCBUZW1wbGF0ZVBhcmFtZXRlcnMsIHdhaXRGb3JDaGFuZ2VTZXQsXG4gIHdhaXRGb3JTdGFja0RlcGxveSwgd2FpdEZvclN0YWNrRGVsZXRlLCBQYXJhbWV0ZXJWYWx1ZXMsIFBhcmFtZXRlckNoYW5nZXMsIFJlc291cmNlc1RvSW1wb3J0LFxufSBmcm9tICcuL3V0aWwvY2xvdWRmb3JtYXRpb24nO1xuaW1wb3J0IHsgU3RhY2tBY3Rpdml0eU1vbml0b3IsIFN0YWNrQWN0aXZpdHlQcm9ncmVzcyB9IGZyb20gJy4vdXRpbC9jbG91ZGZvcm1hdGlvbi9zdGFjay1hY3Rpdml0eS1tb25pdG9yJztcblxudHlwZSBUZW1wbGF0ZUJvZHlQYXJhbWV0ZXIgPSB7XG4gIFRlbXBsYXRlQm9keT86IHN0cmluZ1xuICBUZW1wbGF0ZVVSTD86IHN0cmluZ1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBEZXBsb3lTdGFja1Jlc3VsdCB7XG4gIHJlYWRvbmx5IG5vT3A6IGJvb2xlYW47XG4gIHJlYWRvbmx5IG91dHB1dHM6IHsgW25hbWU6IHN0cmluZ106IHN0cmluZyB9O1xuICByZWFkb25seSBzdGFja0Fybjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERlcGxveVN0YWNrT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgc3RhY2sgdG8gYmUgZGVwbG95ZWRcbiAgICovXG4gIHN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3Q7XG5cbiAgLyoqXG4gICAqIFRoZSBlbnZpcm9ubWVudCB0byBkZXBsb3kgdGhpcyBzdGFjayBpblxuICAgKlxuICAgKiBUaGUgZW52aXJvbm1lbnQgb24gdGhlIHN0YWNrIGFydGlmYWN0IG1heSBiZSB1bnJlc29sdmVkLCB0aGlzIG9uZVxuICAgKiBtdXN0IGJlIHJlc29sdmVkLlxuICAgKi9cbiAgcmVzb2x2ZWRFbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnQ7XG5cbiAgLyoqXG4gICAqIFRoZSBTREsgdG8gdXNlIGZvciBkZXBsb3lpbmcgdGhlIHN0YWNrXG4gICAqXG4gICAqIFNob3VsZCBoYXZlIGJlZW4gaW5pdGlhbGl6ZWQgd2l0aCB0aGUgY29ycmVjdCByb2xlIHdpdGggd2hpY2hcbiAgICogc3RhY2sgb3BlcmF0aW9ucyBzaG91bGQgYmUgcGVyZm9ybWVkLlxuICAgKi9cbiAgc2RrOiBJU0RLO1xuXG4gIC8qKlxuICAgKiBTREsgcHJvdmlkZXIgKHNlZWRlZCB3aXRoIGRlZmF1bHQgY3JlZGVudGlhbHMpXG4gICAqXG4gICAqIFdpbGwgZXhjbHVzaXZlbHkgYmUgdXNlZCB0byBhc3N1bWUgcHVibGlzaGluZyBjcmVkZW50aWFscyAod2hpY2ggbXVzdFxuICAgKiBzdGFydCBvdXQgZnJvbSBjdXJyZW50IGNyZWRlbnRpYWxzIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB3ZSd2ZSBhc3N1bWVkIGFuXG4gICAqIGFjdGlvbiByb2xlIHRvIHRvdWNoIHRoZSBzdGFjayBvciBub3QpLlxuICAgKlxuICAgKiBVc2VkIGZvciB0aGUgZm9sbG93aW5nIHB1cnBvc2VzOlxuICAgKlxuICAgKiAtIFB1Ymxpc2ggbGVnYWN5IGFzc2V0cy5cbiAgICogLSBVcGxvYWQgbGFyZ2UgQ2xvdWRGb3JtYXRpb24gdGVtcGxhdGVzIHRvIHRoZSBzdGFnaW5nIGJ1Y2tldC5cbiAgICovXG4gIHNka1Byb3ZpZGVyOiBTZGtQcm92aWRlcjtcblxuICAvKipcbiAgICogSW5mb3JtYXRpb24gYWJvdXQgdGhlIGJvb3RzdHJhcCBzdGFjayBmb3VuZCBpbiB0aGUgdGFyZ2V0IGVudmlyb25tZW50XG4gICAqL1xuICB0b29sa2l0SW5mbzogVG9vbGtpdEluZm87XG5cbiAgLyoqXG4gICAqIFJvbGUgdG8gcGFzcyB0byBDbG91ZEZvcm1hdGlvbiB0byBleGVjdXRlIHRoZSBjaGFuZ2Ugc2V0XG4gICAqXG4gICAqIEBkZWZhdWx0IC0gUm9sZSBzcGVjaWZpZWQgb24gc3RhY2ssIG90aGVyd2lzZSBjdXJyZW50XG4gICAqL1xuICByb2xlQXJuPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBOb3RpZmljYXRpb24gQVJOcyB0byBwYXNzIHRvIENsb3VkRm9ybWF0aW9uIHRvIG5vdGlmeSB3aGVuIHRoZSBjaGFuZ2Ugc2V0IGhhcyBjb21wbGV0ZWRcbiAgICpcbiAgICogQGRlZmF1bHQgLSBObyBub3RpZmljYXRpb25zXG4gICAqL1xuICBub3RpZmljYXRpb25Bcm5zPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIE5hbWUgdG8gZGVwbG95IHRoZSBzdGFjayB1bmRlclxuICAgKlxuICAgKiBAZGVmYXVsdCAtIE5hbWUgZnJvbSBhc3NlbWJseVxuICAgKi9cbiAgZGVwbG95TmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogUXVpZXQgb3IgdmVyYm9zZSBkZXBsb3ltZW50XG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBxdWlldD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXNzZXQgSURzIHdoaWNoIHNob3VsZG4ndCBiZSBidWlsdFxuICAgKlxuICAgKiBAZGVmYXVsdCAtIEJ1aWxkIGFsbCBhc3NldHNcbiAgICovXG4gIHJldXNlQXNzZXRzPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIFRhZ3MgdG8gcGFzcyB0byBDbG91ZEZvcm1hdGlvbiB0byBhZGQgdG8gc3RhY2tcbiAgICpcbiAgICogQGRlZmF1bHQgLSBObyB0YWdzXG4gICAqL1xuICB0YWdzPzogVGFnW107XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZXhlY3V0ZSB0aGUgY2hhbmdlc2V0IG9yIGxlYXZlIGl0IGluIHJldmlldy5cbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgZXhlY3V0ZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIG5hbWUgdG8gdXNlIGZvciB0aGUgQ2xvdWRGb3JtYXRpb24gY2hhbmdlIHNldC5cbiAgICogSWYgbm90IHByb3ZpZGVkLCBhIG5hbWUgd2lsbCBiZSBnZW5lcmF0ZWQgYXV0b21hdGljYWxseS5cbiAgICovXG4gIGNoYW5nZVNldE5hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBjb2xsZWN0aW9uIG9mIGV4dHJhIHBhcmFtZXRlcnNcbiAgICogKGluIGFkZGl0aW9uIHRvIHRob3NlIHVzZWQgZm9yIGFzc2V0cylcbiAgICogdG8gcGFzcyB0byB0aGUgZGVwbG95ZWQgdGVtcGxhdGUuXG4gICAqIE5vdGUgdGhhdCBwYXJhbWV0ZXJzIHdpdGggYHVuZGVmaW5lZGAgb3IgZW1wdHkgdmFsdWVzIHdpbGwgYmUgaWdub3JlZCxcbiAgICogYW5kIG5vdCBwYXNzZWQgdG8gdGhlIHRlbXBsYXRlLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIG5vIGFkZGl0aW9uYWwgcGFyYW1ldGVycyB3aWxsIGJlIHBhc3NlZCB0byB0aGUgdGVtcGxhdGVcbiAgICovXG4gIHBhcmFtZXRlcnM/OiB7IFtuYW1lOiBzdHJpbmddOiBzdHJpbmcgfCB1bmRlZmluZWQgfTtcblxuICAvKipcbiAgICogVXNlIHByZXZpb3VzIHZhbHVlcyBmb3IgdW5zcGVjaWZpZWQgcGFyYW1ldGVyc1xuICAgKlxuICAgKiBJZiBub3Qgc2V0LCBhbGwgcGFyYW1ldGVycyBtdXN0IGJlIHNwZWNpZmllZCBmb3IgZXZlcnkgZGVwbG95bWVudC5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHVzZVByZXZpb3VzUGFyYW1ldGVycz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIERpc3BsYXkgbW9kZSBmb3Igc3RhY2sgZGVwbG95bWVudCBwcm9ncmVzcy5cbiAgICpcbiAgICogQGRlZmF1bHQgU3RhY2tBY3Rpdml0eVByb2dyZXNzLkJhciBzdGFjayBldmVudHMgd2lsbCBiZSBkaXNwbGF5ZWQgZm9yXG4gICAqICAgdGhlIHJlc291cmNlIGN1cnJlbnRseSBiZWluZyBkZXBsb3llZC5cbiAgICovXG4gIHByb2dyZXNzPzogU3RhY2tBY3Rpdml0eVByb2dyZXNzO1xuXG4gIC8qKlxuICAgKiBEZXBsb3kgZXZlbiBpZiB0aGUgZGVwbG95ZWQgdGVtcGxhdGUgaXMgaWRlbnRpY2FsIHRvIHRoZSBvbmUgd2UgYXJlIGFib3V0IHRvIGRlcGxveS5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGZvcmNlPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogV2hldGhlciB3ZSBhcmUgb24gYSBDSSBzeXN0ZW1cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IGNpPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogUm9sbGJhY2sgZmFpbGVkIGRlcGxveW1lbnRzXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IHJvbGxiYWNrPzogYm9vbGVhbjtcblxuICAvKlxuICAgKiBXaGV0aGVyIHRvIHBlcmZvcm0gYSAnaG90c3dhcCcgZGVwbG95bWVudC5cbiAgICogQSAnaG90c3dhcCcgZGVwbG95bWVudCB3aWxsIGF0dGVtcHQgdG8gc2hvcnQtY2lyY3VpdCBDbG91ZEZvcm1hdGlvblxuICAgKiBhbmQgdXBkYXRlIHRoZSBhZmZlY3RlZCByZXNvdXJjZXMgbGlrZSBMYW1iZGEgZnVuY3Rpb25zIGRpcmVjdGx5LlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIGZhbHNlIGZvciByZWd1bGFyIGRlcGxveW1lbnRzLCB0cnVlIGZvciAnd2F0Y2gnIGRlcGxveW1lbnRzXG4gICAqL1xuICByZWFkb25seSBob3Rzd2FwPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogVGhlIGV4dHJhIHN0cmluZyB0byBhcHBlbmQgdG8gdGhlIFVzZXItQWdlbnQgaGVhZGVyIHdoZW4gcGVyZm9ybWluZyBBV1MgU0RLIGNhbGxzLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIG5vdGhpbmcgZXh0cmEgaXMgYXBwZW5kZWQgdG8gdGhlIFVzZXItQWdlbnQgaGVhZGVyXG4gICAqL1xuICByZWFkb25seSBleHRyYVVzZXJBZ2VudD86IHN0cmluZztcblxuICAvKipcbiAgICogSWYgc2V0LCBjaGFuZ2Ugc2V0IG9mIHR5cGUgSU1QT1JUIHdpbGwgYmUgY3JlYXRlZCwgYW5kIHJlc291cmNlc1RvSW1wb3J0XG4gICAqIHBhc3NlZCB0byBpdC5cbiAgICovXG4gIHJlYWRvbmx5IHJlc291cmNlc1RvSW1wb3J0PzogUmVzb3VyY2VzVG9JbXBvcnQ7XG5cbiAgLyoqXG4gICAqIElmIHByZXNlbnQsIHVzZSB0aGlzIGdpdmVuIHRlbXBsYXRlIGluc3RlYWQgb2YgdGhlIHN0b3JlZCBvbmVcbiAgICpcbiAgICogQGRlZmF1bHQgLSBVc2UgdGhlIHN0b3JlZCB0ZW1wbGF0ZVxuICAgKi9cbiAgcmVhZG9ubHkgb3ZlcnJpZGVUZW1wbGF0ZT86IGFueTtcbn1cblxuY29uc3QgTEFSR0VfVEVNUExBVEVfU0laRV9LQiA9IDUwO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVwbG95U3RhY2sob3B0aW9uczogRGVwbG95U3RhY2tPcHRpb25zKTogUHJvbWlzZTxEZXBsb3lTdGFja1Jlc3VsdD4ge1xuICBjb25zdCBzdGFja0FydGlmYWN0ID0gb3B0aW9ucy5zdGFjaztcblxuICBjb25zdCBzdGFja0VudiA9IG9wdGlvbnMucmVzb2x2ZWRFbnZpcm9ubWVudDtcblxuICBvcHRpb25zLnNkay5hcHBlbmRDdXN0b21Vc2VyQWdlbnQob3B0aW9ucy5leHRyYVVzZXJBZ2VudCk7XG4gIGNvbnN0IGNmbiA9IG9wdGlvbnMuc2RrLmNsb3VkRm9ybWF0aW9uKCk7XG4gIGNvbnN0IGRlcGxveU5hbWUgPSBvcHRpb25zLmRlcGxveU5hbWUgfHwgc3RhY2tBcnRpZmFjdC5zdGFja05hbWU7XG4gIGxldCBjbG91ZEZvcm1hdGlvblN0YWNrID0gYXdhaXQgQ2xvdWRGb3JtYXRpb25TdGFjay5sb29rdXAoY2ZuLCBkZXBsb3lOYW1lKTtcblxuICBpZiAoY2xvdWRGb3JtYXRpb25TdGFjay5zdGFja1N0YXR1cy5pc0NyZWF0aW9uRmFpbHVyZSkge1xuICAgIGRlYnVnKGBGb3VuZCBleGlzdGluZyBzdGFjayAke2RlcGxveU5hbWV9IHRoYXQgaGFkIHByZXZpb3VzbHkgZmFpbGVkIGNyZWF0aW9uLiBEZWxldGluZyBpdCBiZWZvcmUgYXR0ZW1wdGluZyB0byByZS1jcmVhdGUgaXQuYCk7XG4gICAgYXdhaXQgY2ZuLmRlbGV0ZVN0YWNrKHsgU3RhY2tOYW1lOiBkZXBsb3lOYW1lIH0pLnByb21pc2UoKTtcbiAgICBjb25zdCBkZWxldGVkU3RhY2sgPSBhd2FpdCB3YWl0Rm9yU3RhY2tEZWxldGUoY2ZuLCBkZXBsb3lOYW1lKTtcbiAgICBpZiAoZGVsZXRlZFN0YWNrICYmIGRlbGV0ZWRTdGFjay5zdGFja1N0YXR1cy5uYW1lICE9PSAnREVMRVRFX0NPTVBMRVRFJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgZGVsZXRpbmcgc3RhY2sgJHtkZXBsb3lOYW1lfSB0aGF0IGhhZCBwcmV2aW91c2x5IGZhaWxlZCBjcmVhdGlvbiAoY3VycmVudCBzdGF0ZTogJHtkZWxldGVkU3RhY2suc3RhY2tTdGF0dXN9KWApO1xuICAgIH1cbiAgICAvLyBVcGRhdGUgdmFyaWFibGUgdG8gbWFyayB0aGF0IHRoZSBzdGFjayBkb2VzIG5vdCBleGlzdCBhbnltb3JlLCBidXQgYXZvaWRcbiAgICAvLyBkb2luZyBhbiBhY3R1YWwgbG9va3VwIGluIENsb3VkRm9ybWF0aW9uICh3aGljaCB3b3VsZCBiZSBzaWxseSB0byBkbyBpZlxuICAgIC8vIHdlIGp1c3QgZGVsZXRlZCBpdCkuXG4gICAgY2xvdWRGb3JtYXRpb25TdGFjayA9IENsb3VkRm9ybWF0aW9uU3RhY2suZG9lc05vdEV4aXN0KGNmbiwgZGVwbG95TmFtZSk7XG4gIH1cblxuICAvLyBEZXRlY3QgXCJsZWdhY3lcIiBhc3NldHMgKHdoaWNoIHJlbWFpbiBpbiB0aGUgbWV0YWRhdGEpIGFuZCBwdWJsaXNoIHRoZW0gdmlhXG4gIC8vIGFuIGFkLWhvYyBhc3NldCBtYW5pZmVzdCwgd2hpbGUgcGFzc2luZyB0aGVpciBsb2NhdGlvbnMgdmlhIHRlbXBsYXRlXG4gIC8vIHBhcmFtZXRlcnMuXG4gIGNvbnN0IGxlZ2FjeUFzc2V0cyA9IG5ldyBBc3NldE1hbmlmZXN0QnVpbGRlcigpO1xuICBjb25zdCBhc3NldFBhcmFtcyA9IGF3YWl0IGFkZE1ldGFkYXRhQXNzZXRzVG9NYW5pZmVzdChzdGFja0FydGlmYWN0LCBsZWdhY3lBc3NldHMsIG9wdGlvbnMudG9vbGtpdEluZm8sIG9wdGlvbnMucmV1c2VBc3NldHMpO1xuXG4gIGNvbnN0IGZpbmFsUGFyYW1ldGVyVmFsdWVzID0geyAuLi5vcHRpb25zLnBhcmFtZXRlcnMsIC4uLmFzc2V0UGFyYW1zIH07XG5cbiAgY29uc3QgdGVtcGxhdGVQYXJhbXMgPSBUZW1wbGF0ZVBhcmFtZXRlcnMuZnJvbVRlbXBsYXRlKHN0YWNrQXJ0aWZhY3QudGVtcGxhdGUpO1xuICBjb25zdCBzdGFja1BhcmFtcyA9IG9wdGlvbnMudXNlUHJldmlvdXNQYXJhbWV0ZXJzXG4gICAgPyB0ZW1wbGF0ZVBhcmFtcy51cGRhdGVFeGlzdGluZyhmaW5hbFBhcmFtZXRlclZhbHVlcywgY2xvdWRGb3JtYXRpb25TdGFjay5wYXJhbWV0ZXJzKVxuICAgIDogdGVtcGxhdGVQYXJhbXMuc3VwcGx5QWxsKGZpbmFsUGFyYW1ldGVyVmFsdWVzKTtcblxuICBpZiAoYXdhaXQgY2FuU2tpcERlcGxveShvcHRpb25zLCBjbG91ZEZvcm1hdGlvblN0YWNrLCBzdGFja1BhcmFtcy5oYXNDaGFuZ2VzKGNsb3VkRm9ybWF0aW9uU3RhY2sucGFyYW1ldGVycykpKSB7XG4gICAgZGVidWcoYCR7ZGVwbG95TmFtZX06IHNraXBwaW5nIGRlcGxveW1lbnQgKHVzZSAtLWZvcmNlIHRvIG92ZXJyaWRlKWApO1xuICAgIC8vIGlmIHdlIGNhbiBza2lwIGRlcGxveW1lbnQgYW5kIHdlIGFyZSBwZXJmb3JtaW5nIGEgaG90c3dhcCwgbGV0IHRoZSB1c2VyIGtub3dcbiAgICAvLyB0aGF0IG5vIGhvdHN3YXAgZGVwbG95bWVudCBoYXBwZW5lZFxuICAgIGlmIChvcHRpb25zLmhvdHN3YXApIHtcbiAgICAgIHByaW50KGBcXG4gJHtJQ09OfSAlc1xcbmAsIGNoYWxrLmJvbGQoJ2hvdHN3YXAgZGVwbG95bWVudCBza2lwcGVkIC0gbm8gY2hhbmdlcyB3ZXJlIGRldGVjdGVkICh1c2UgLS1mb3JjZSB0byBvdmVycmlkZSknKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBub09wOiB0cnVlLFxuICAgICAgb3V0cHV0czogY2xvdWRGb3JtYXRpb25TdGFjay5vdXRwdXRzLFxuICAgICAgc3RhY2tBcm46IGNsb3VkRm9ybWF0aW9uU3RhY2suc3RhY2tJZCxcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGRlYnVnKGAke2RlcGxveU5hbWV9OiBkZXBsb3lpbmcuLi5gKTtcbiAgfVxuXG4gIGNvbnN0IGJvZHlQYXJhbWV0ZXIgPSBhd2FpdCBtYWtlQm9keVBhcmFtZXRlcihcbiAgICBzdGFja0FydGlmYWN0LFxuICAgIG9wdGlvbnMucmVzb2x2ZWRFbnZpcm9ubWVudCxcbiAgICBsZWdhY3lBc3NldHMsXG4gICAgb3B0aW9ucy50b29sa2l0SW5mbyxcbiAgICBvcHRpb25zLnNkayxcbiAgICBvcHRpb25zLm92ZXJyaWRlVGVtcGxhdGUpO1xuICBhd2FpdCBwdWJsaXNoQXNzZXRzKGxlZ2FjeUFzc2V0cy50b01hbmlmZXN0KHN0YWNrQXJ0aWZhY3QuYXNzZW1ibHkuZGlyZWN0b3J5KSwgb3B0aW9ucy5zZGtQcm92aWRlciwgc3RhY2tFbnYpO1xuXG4gIGlmIChvcHRpb25zLmhvdHN3YXApIHtcbiAgICAvLyBhdHRlbXB0IHRvIHNob3J0LWNpcmN1aXQgdGhlIGRlcGxveW1lbnQgaWYgcG9zc2libGVcbiAgICB0cnkge1xuICAgICAgY29uc3QgaG90c3dhcERlcGxveW1lbnRSZXN1bHQgPSBhd2FpdCB0cnlIb3Rzd2FwRGVwbG95bWVudChvcHRpb25zLnNka1Byb3ZpZGVyLCBhc3NldFBhcmFtcywgY2xvdWRGb3JtYXRpb25TdGFjaywgc3RhY2tBcnRpZmFjdCk7XG4gICAgICBpZiAoaG90c3dhcERlcGxveW1lbnRSZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIGhvdHN3YXBEZXBsb3ltZW50UmVzdWx0O1xuICAgICAgfVxuICAgICAgcHJpbnQoJ0NvdWxkIG5vdCBwZXJmb3JtIGEgaG90c3dhcCBkZXBsb3ltZW50LCBhcyB0aGUgc3RhY2sgJXMgY29udGFpbnMgbm9uLUFzc2V0IGNoYW5nZXMnLCBzdGFja0FydGlmYWN0LmRpc3BsYXlOYW1lKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoIShlIGluc3RhbmNlb2YgQ2ZuRXZhbHVhdGlvbkV4Y2VwdGlvbikpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIHByaW50KCdDb3VsZCBub3QgcGVyZm9ybSBhIGhvdHN3YXAgZGVwbG95bWVudCwgYmVjYXVzZSB0aGUgQ2xvdWRGb3JtYXRpb24gdGVtcGxhdGUgY291bGQgbm90IGJlIHJlc29sdmVkOiAlcycsIGUubWVzc2FnZSk7XG4gICAgfVxuICAgIHByaW50KCdGYWxsaW5nIGJhY2sgdG8gZG9pbmcgYSBmdWxsIGRlcGxveW1lbnQnKTtcbiAgfVxuXG4gIC8vIGNvdWxkIG5vdCBzaG9ydC1jaXJjdWl0IHRoZSBkZXBsb3ltZW50LCBwZXJmb3JtIGEgZnVsbCBDRk4gZGVwbG95IGluc3RlYWRcbiAgcmV0dXJuIHByZXBhcmVBbmRFeGVjdXRlQ2hhbmdlU2V0KG9wdGlvbnMsIGNsb3VkRm9ybWF0aW9uU3RhY2ssIHN0YWNrQXJ0aWZhY3QsIHN0YWNrUGFyYW1zLCBib2R5UGFyYW1ldGVyKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcHJlcGFyZUFuZEV4ZWN1dGVDaGFuZ2VTZXQoXG4gIG9wdGlvbnM6IERlcGxveVN0YWNrT3B0aW9ucywgY2xvdWRGb3JtYXRpb25TdGFjazogQ2xvdWRGb3JtYXRpb25TdGFjayxcbiAgc3RhY2tBcnRpZmFjdDogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0LCBzdGFja1BhcmFtczogUGFyYW1ldGVyVmFsdWVzLCBib2R5UGFyYW1ldGVyOiBUZW1wbGF0ZUJvZHlQYXJhbWV0ZXIsXG4pOiBQcm9taXNlPERlcGxveVN0YWNrUmVzdWx0PiB7XG4gIC8vIGlmIHdlIGdvdCBoZXJlLCBhbmQgaG90c3dhcCBpcyBlbmFibGVkLCB0aGF0IG1lYW5zIGNoYW5nZXMgY291bGRuJ3QgYmUgaG90c3dhcHBlZCxcbiAgLy8gYW5kIHdlIGhhZCB0byBmYWxsIGJhY2sgb24gYSBmdWxsIGRlcGxveW1lbnQuIE5vdGUgdGhhdCBmYWN0IGluIG91ciBVc2VyLUFnZW50XG4gIGlmIChvcHRpb25zLmhvdHN3YXApIHtcbiAgICBvcHRpb25zLnNkay5hcHBlbmRDdXN0b21Vc2VyQWdlbnQoJ2Nkay1ob3Rzd2FwL2ZhbGxiYWNrJyk7XG4gIH1cblxuICBjb25zdCBjZm4gPSBvcHRpb25zLnNkay5jbG91ZEZvcm1hdGlvbigpO1xuICBjb25zdCBkZXBsb3lOYW1lID0gb3B0aW9ucy5kZXBsb3lOYW1lID8/IHN0YWNrQXJ0aWZhY3Quc3RhY2tOYW1lO1xuXG4gIGNvbnN0IGNoYW5nZVNldE5hbWUgPSBvcHRpb25zLmNoYW5nZVNldE5hbWUgPz8gJ2Nkay1kZXBsb3ktY2hhbmdlLXNldCc7XG4gIGlmIChjbG91ZEZvcm1hdGlvblN0YWNrLmV4aXN0cykge1xuICAgIC8vRGVsZXRlIGFueSBleGlzdGluZyBjaGFuZ2Ugc2V0cyBnZW5lcmF0ZWQgYnkgQ0RLIHNpbmNlIGNoYW5nZSBzZXQgbmFtZXMgbXVzdCBiZSB1bmlxdWUuXG4gICAgLy9UaGUgZGVsZXRlIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bCBhcyBsb25nIGFzIHRoZSBzdGFjayBleGlzdHMgKGV2ZW4gaWYgdGhlIGNoYW5nZSBzZXQgZG9lcyBub3QgZXhpc3QpLlxuICAgIGRlYnVnKGBSZW1vdmluZyBleGlzdGluZyBjaGFuZ2Ugc2V0IHdpdGggbmFtZSAke2NoYW5nZVNldE5hbWV9IGlmIGl0IGV4aXN0c2ApO1xuICAgIGF3YWl0IGNmbi5kZWxldGVDaGFuZ2VTZXQoeyBTdGFja05hbWU6IGRlcGxveU5hbWUsIENoYW5nZVNldE5hbWU6IGNoYW5nZVNldE5hbWUgfSkucHJvbWlzZSgpO1xuICB9XG5cbiAgY29uc3QgdXBkYXRlID0gY2xvdWRGb3JtYXRpb25TdGFjay5leGlzdHMgJiYgY2xvdWRGb3JtYXRpb25TdGFjay5zdGFja1N0YXR1cy5uYW1lICE9PSAnUkVWSUVXX0lOX1BST0dSRVNTJztcblxuICBkZWJ1ZyhgQXR0ZW1wdGluZyB0byBjcmVhdGUgQ2hhbmdlU2V0IHdpdGggbmFtZSAke2NoYW5nZVNldE5hbWV9IHRvICR7dXBkYXRlID8gJ3VwZGF0ZScgOiAnY3JlYXRlJ30gc3RhY2sgJHtkZXBsb3lOYW1lfWApO1xuICBwcmludCgnJXM6IGNyZWF0aW5nIENsb3VkRm9ybWF0aW9uIGNoYW5nZXNldC4uLicsIGNoYWxrLmJvbGQoZGVwbG95TmFtZSkpO1xuICBjb25zdCBleGVjdXRpb25JZCA9IHV1aWQudjQoKTtcbiAgY29uc3QgY2hhbmdlU2V0ID0gYXdhaXQgY2ZuLmNyZWF0ZUNoYW5nZVNldCh7XG4gICAgU3RhY2tOYW1lOiBkZXBsb3lOYW1lLFxuICAgIENoYW5nZVNldE5hbWU6IGNoYW5nZVNldE5hbWUsXG4gICAgQ2hhbmdlU2V0VHlwZTogb3B0aW9ucy5yZXNvdXJjZXNUb0ltcG9ydCA/ICdJTVBPUlQnIDogdXBkYXRlID8gJ1VQREFURScgOiAnQ1JFQVRFJyxcbiAgICBSZXNvdXJjZXNUb0ltcG9ydDogb3B0aW9ucy5yZXNvdXJjZXNUb0ltcG9ydCxcbiAgICBEZXNjcmlwdGlvbjogYENESyBDaGFuZ2VzZXQgZm9yIGV4ZWN1dGlvbiAke2V4ZWN1dGlvbklkfWAsXG4gICAgVGVtcGxhdGVCb2R5OiBib2R5UGFyYW1ldGVyLlRlbXBsYXRlQm9keSxcbiAgICBUZW1wbGF0ZVVSTDogYm9keVBhcmFtZXRlci5UZW1wbGF0ZVVSTCxcbiAgICBQYXJhbWV0ZXJzOiBzdGFja1BhcmFtcy5hcGlQYXJhbWV0ZXJzLFxuICAgIFJvbGVBUk46IG9wdGlvbnMucm9sZUFybixcbiAgICBOb3RpZmljYXRpb25BUk5zOiBvcHRpb25zLm5vdGlmaWNhdGlvbkFybnMsXG4gICAgQ2FwYWJpbGl0aWVzOiBbJ0NBUEFCSUxJVFlfSUFNJywgJ0NBUEFCSUxJVFlfTkFNRURfSUFNJywgJ0NBUEFCSUxJVFlfQVVUT19FWFBBTkQnXSxcbiAgICBUYWdzOiBvcHRpb25zLnRhZ3MsXG4gIH0pLnByb21pc2UoKTtcbiAgZGVidWcoJ0luaXRpYXRlZCBjcmVhdGlvbiBvZiBjaGFuZ2VzZXQ6ICVzOyB3YWl0aW5nIGZvciBpdCB0byBmaW5pc2ggY3JlYXRpbmcuLi4nLCBjaGFuZ2VTZXQuSWQpO1xuICBjb25zdCBjaGFuZ2VTZXREZXNjcmlwdGlvbiA9IGF3YWl0IHdhaXRGb3JDaGFuZ2VTZXQoY2ZuLCBkZXBsb3lOYW1lLCBjaGFuZ2VTZXROYW1lKTtcblxuICAvLyBVcGRhdGUgdGVybWluYXRpb24gcHJvdGVjdGlvbiBvbmx5IGlmIGl0IGhhcyBjaGFuZ2VkLlxuICBjb25zdCB0ZXJtaW5hdGlvblByb3RlY3Rpb24gPSBzdGFja0FydGlmYWN0LnRlcm1pbmF0aW9uUHJvdGVjdGlvbiA/PyBmYWxzZTtcbiAgaWYgKCEhY2xvdWRGb3JtYXRpb25TdGFjay50ZXJtaW5hdGlvblByb3RlY3Rpb24gIT09IHRlcm1pbmF0aW9uUHJvdGVjdGlvbikge1xuICAgIGRlYnVnKCdVcGRhdGluZyB0ZXJtaW5hdGlvbiBwcm90ZWN0aW9uIGZyb20gJXMgdG8gJXMgZm9yIHN0YWNrICVzJywgY2xvdWRGb3JtYXRpb25TdGFjay50ZXJtaW5hdGlvblByb3RlY3Rpb24sIHRlcm1pbmF0aW9uUHJvdGVjdGlvbiwgZGVwbG95TmFtZSk7XG4gICAgYXdhaXQgY2ZuLnVwZGF0ZVRlcm1pbmF0aW9uUHJvdGVjdGlvbih7XG4gICAgICBTdGFja05hbWU6IGRlcGxveU5hbWUsXG4gICAgICBFbmFibGVUZXJtaW5hdGlvblByb3RlY3Rpb246IHRlcm1pbmF0aW9uUHJvdGVjdGlvbixcbiAgICB9KS5wcm9taXNlKCk7XG4gICAgZGVidWcoJ1Rlcm1pbmF0aW9uIHByb3RlY3Rpb24gdXBkYXRlZCB0byAlcyBmb3Igc3RhY2sgJXMnLCB0ZXJtaW5hdGlvblByb3RlY3Rpb24sIGRlcGxveU5hbWUpO1xuICB9XG5cbiAgaWYgKGNoYW5nZVNldEhhc05vQ2hhbmdlcyhjaGFuZ2VTZXREZXNjcmlwdGlvbikpIHtcbiAgICBkZWJ1ZygnTm8gY2hhbmdlcyBhcmUgdG8gYmUgcGVyZm9ybWVkIG9uICVzLicsIGRlcGxveU5hbWUpO1xuICAgIGlmIChvcHRpb25zLmV4ZWN1dGUpIHtcbiAgICAgIGRlYnVnKCdEZWxldGluZyBlbXB0eSBjaGFuZ2Ugc2V0ICVzJywgY2hhbmdlU2V0LklkKTtcbiAgICAgIGF3YWl0IGNmbi5kZWxldGVDaGFuZ2VTZXQoeyBTdGFja05hbWU6IGRlcGxveU5hbWUsIENoYW5nZVNldE5hbWU6IGNoYW5nZVNldE5hbWUgfSkucHJvbWlzZSgpO1xuICAgIH1cbiAgICByZXR1cm4geyBub09wOiB0cnVlLCBvdXRwdXRzOiBjbG91ZEZvcm1hdGlvblN0YWNrLm91dHB1dHMsIHN0YWNrQXJuOiBjaGFuZ2VTZXQuU3RhY2tJZCEgfTtcbiAgfVxuXG4gIGNvbnN0IGV4ZWN1dGUgPSBvcHRpb25zLmV4ZWN1dGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRpb25zLmV4ZWN1dGU7XG4gIGlmIChleGVjdXRlKSB7XG4gICAgZGVidWcoJ0luaXRpYXRpbmcgZXhlY3V0aW9uIG9mIGNoYW5nZXNldCAlcyBvbiBzdGFjayAlcycsIGNoYW5nZVNldC5JZCwgZGVwbG95TmFtZSk7XG5cbiAgICBjb25zdCBzaG91bGREaXNhYmxlUm9sbGJhY2sgPSBvcHRpb25zLnJvbGxiYWNrID09PSBmYWxzZTtcbiAgICAvLyBEbyBhIGJpdCBvZiBjb250b3J0aW9ucyB0byBvbmx5IHBhc3MgdGhlIGBEaXNhYmxlUm9sbGJhY2tgIGZsYWcgaWYgaXQncyB0cnVlLiBUaGF0IHdheSxcbiAgICAvLyBDbG91ZEZvcm1hdGlvbiB3b24ndCBiYWxrIGF0IHRoZSB1bnJlY29nbml6ZWQgb3B0aW9uIGluIHJlZ2lvbnMgd2hlcmUgdGhlIGZlYXR1cmUgaXMgbm90IGF2YWlsYWJsZSB5ZXQuXG4gICAgY29uc3QgZGlzYWJsZVJvbGxiYWNrID0gc2hvdWxkRGlzYWJsZVJvbGxiYWNrID8geyBEaXNhYmxlUm9sbGJhY2s6IHRydWUgfSA6IHVuZGVmaW5lZDtcblxuICAgIGF3YWl0IGNmbi5leGVjdXRlQ2hhbmdlU2V0KHsgU3RhY2tOYW1lOiBkZXBsb3lOYW1lLCBDaGFuZ2VTZXROYW1lOiBjaGFuZ2VTZXROYW1lLCAuLi5kaXNhYmxlUm9sbGJhY2sgfSkucHJvbWlzZSgpO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICBjb25zdCBjaGFuZ2VTZXRMZW5ndGg6IG51bWJlciA9IChjaGFuZ2VTZXREZXNjcmlwdGlvbi5DaGFuZ2VzID8/IFtdKS5sZW5ndGg7XG4gICAgY29uc3QgbW9uaXRvciA9IG9wdGlvbnMucXVpZXQgPyB1bmRlZmluZWQgOiBTdGFja0FjdGl2aXR5TW9uaXRvci53aXRoRGVmYXVsdFByaW50ZXIoY2ZuLCBkZXBsb3lOYW1lLCBzdGFja0FydGlmYWN0LCB7XG4gICAgICAvLyArMSBmb3IgdGhlIGV4dHJhIGV2ZW50IGVtaXR0ZWQgZnJvbSB1cGRhdGVzLlxuICAgICAgcmVzb3VyY2VzVG90YWw6IGNsb3VkRm9ybWF0aW9uU3RhY2suZXhpc3RzID8gY2hhbmdlU2V0TGVuZ3RoICsgMSA6IGNoYW5nZVNldExlbmd0aCxcbiAgICAgIHByb2dyZXNzOiBvcHRpb25zLnByb2dyZXNzLFxuICAgICAgY2hhbmdlU2V0Q3JlYXRpb25UaW1lOiBjaGFuZ2VTZXREZXNjcmlwdGlvbi5DcmVhdGlvblRpbWUsXG4gICAgfSkuc3RhcnQoKTtcbiAgICBkZWJ1ZygnRXhlY3V0aW9uIG9mIGNoYW5nZXNldCAlcyBvbiBzdGFjayAlcyBoYXMgc3RhcnRlZDsgd2FpdGluZyBmb3IgdGhlIHVwZGF0ZSB0byBjb21wbGV0ZS4uLicsIGNoYW5nZVNldC5JZCwgZGVwbG95TmFtZSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZpbmFsU3RhY2sgPSBhd2FpdCB3YWl0Rm9yU3RhY2tEZXBsb3koY2ZuLCBkZXBsb3lOYW1lKTtcblxuICAgICAgLy8gVGhpcyBzaG91bGRuJ3QgcmVhbGx5IGhhcHBlbiwgYnV0IGNhdGNoIGl0IGFueXdheS4gWW91IG5ldmVyIGtub3cuXG4gICAgICBpZiAoIWZpbmFsU3RhY2spIHsgdGhyb3cgbmV3IEVycm9yKCdTdGFjayBkZXBsb3kgZmFpbGVkICh0aGUgc3RhY2sgZGlzYXBwZWFyZWQgd2hpbGUgd2Ugd2VyZSBkZXBsb3lpbmcgaXQpJyk7IH1cbiAgICAgIGNsb3VkRm9ybWF0aW9uU3RhY2sgPSBmaW5hbFN0YWNrO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBhd2FpdCBtb25pdG9yPy5zdG9wKCk7XG4gICAgfVxuICAgIGRlYnVnKCdTdGFjayAlcyBoYXMgY29tcGxldGVkIHVwZGF0aW5nJywgZGVwbG95TmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgcHJpbnQoJ0NoYW5nZXNldCAlcyBjcmVhdGVkIGFuZCB3YWl0aW5nIGluIHJldmlldyBmb3IgbWFudWFsIGV4ZWN1dGlvbiAoLS1uby1leGVjdXRlKScsIGNoYW5nZVNldC5JZCk7XG4gIH1cblxuICByZXR1cm4geyBub09wOiBmYWxzZSwgb3V0cHV0czogY2xvdWRGb3JtYXRpb25TdGFjay5vdXRwdXRzLCBzdGFja0FybjogY2hhbmdlU2V0LlN0YWNrSWQhIH07XG59XG5cbi8qKlxuICogUHJlcGFyZXMgdGhlIGJvZHkgcGFyYW1ldGVyIGZvciArQ3JlYXRlQ2hhbmdlU2V0Ky5cbiAqXG4gKiBJZiB0aGUgdGVtcGxhdGUgaXMgc21hbGwgZW5vdWdoIHRvIGJlIGlubGluZWQgaW50byB0aGUgQVBJIGNhbGwsIGp1c3QgcmV0dXJuXG4gKiBpdCBpbW1lZGlhdGVseS5cbiAqXG4gKiBPdGhlcndpc2UsIGFkZCBpdCB0byB0aGUgYXNzZXQgbWFuaWZlc3QgdG8gZ2V0IHVwbG9hZGVkIHRvIHRoZSBzdGFnaW5nXG4gKiBidWNrZXQgYW5kIHJldHVybiBpdHMgY29vcmRpbmF0ZXMuIElmIHRoZXJlIGlzIG5vIHN0YWdpbmcgYnVja2V0LCBhbiBlcnJvclxuICogaXMgdGhyb3duLlxuICpcbiAqIEBwYXJhbSBzdGFjayAgICAgdGhlIHN5bnRoZXNpemVkIHN0YWNrIHRoYXQgcHJvdmlkZXMgdGhlIENsb3VkRm9ybWF0aW9uIHRlbXBsYXRlXG4gKiBAcGFyYW0gdG9vbGtpdEluZm8gaW5mb3JtYXRpb24gYWJvdXQgdGhlIHRvb2xraXQgc3RhY2tcbiAqL1xuYXN5bmMgZnVuY3Rpb24gbWFrZUJvZHlQYXJhbWV0ZXIoXG4gIHN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3QsXG4gIHJlc29sdmVkRW52aXJvbm1lbnQ6IGN4YXBpLkVudmlyb25tZW50LFxuICBhc3NldE1hbmlmZXN0OiBBc3NldE1hbmlmZXN0QnVpbGRlcixcbiAgdG9vbGtpdEluZm86IFRvb2xraXRJbmZvLFxuICBzZGs6IElTREssXG4gIG92ZXJyaWRlVGVtcGxhdGU/OiBhbnksXG4pOiBQcm9taXNlPFRlbXBsYXRlQm9keVBhcmFtZXRlcj4ge1xuXG4gIC8vIElmIHRoZSB0ZW1wbGF0ZSBoYXMgYWxyZWFkeSBiZWVuIHVwbG9hZGVkIHRvIFMzLCBqdXN0IHVzZSBpdCBmcm9tIHRoZXJlLlxuICBpZiAoc3RhY2suc3RhY2tUZW1wbGF0ZUFzc2V0T2JqZWN0VXJsICYmICFvdmVycmlkZVRlbXBsYXRlKSB7XG4gICAgcmV0dXJuIHsgVGVtcGxhdGVVUkw6IHJlc3RVcmxGcm9tTWFuaWZlc3Qoc3RhY2suc3RhY2tUZW1wbGF0ZUFzc2V0T2JqZWN0VXJsLCByZXNvbHZlZEVudmlyb25tZW50LCBzZGspIH07XG4gIH1cblxuICAvLyBPdGhlcndpc2UsIHBhc3MgdmlhIEFQSSBjYWxsIChpZiBzbWFsbCkgb3IgdXBsb2FkIGhlcmUgKGlmIGxhcmdlKVxuICBjb25zdCB0ZW1wbGF0ZUpzb24gPSB0b1lBTUwob3ZlcnJpZGVUZW1wbGF0ZSA/PyBzdGFjay50ZW1wbGF0ZSk7XG5cbiAgaWYgKHRlbXBsYXRlSnNvbi5sZW5ndGggPD0gTEFSR0VfVEVNUExBVEVfU0laRV9LQiAqIDEwMjQpIHtcbiAgICByZXR1cm4geyBUZW1wbGF0ZUJvZHk6IHRlbXBsYXRlSnNvbiB9O1xuICB9XG5cbiAgaWYgKCF0b29sa2l0SW5mby5mb3VuZCkge1xuICAgIGVycm9yKFxuICAgICAgYFRoZSB0ZW1wbGF0ZSBmb3Igc3RhY2sgXCIke3N0YWNrLmRpc3BsYXlOYW1lfVwiIGlzICR7TWF0aC5yb3VuZCh0ZW1wbGF0ZUpzb24ubGVuZ3RoIC8gMTAyNCl9S2lCLiBgICtcbiAgICAgIGBUZW1wbGF0ZXMgbGFyZ2VyIHRoYW4gJHtMQVJHRV9URU1QTEFURV9TSVpFX0tCfUtpQiBtdXN0IGJlIHVwbG9hZGVkIHRvIFMzLlxcbmAgK1xuICAgICAgJ1J1biB0aGUgZm9sbG93aW5nIGNvbW1hbmQgaW4gb3JkZXIgdG8gc2V0dXAgYW4gUzMgYnVja2V0IGluIHRoaXMgZW52aXJvbm1lbnQsIGFuZCB0aGVuIHJlLWRlcGxveTpcXG5cXG4nLFxuICAgICAgY2hhbGsuYmx1ZShgXFx0JCBjZGsgYm9vdHN0cmFwICR7cmVzb2x2ZWRFbnZpcm9ubWVudC5uYW1lfVxcbmApKTtcblxuICAgIHRocm93IG5ldyBFcnJvcignVGVtcGxhdGUgdG9vIGxhcmdlIHRvIGRlcGxveSAoXCJjZGsgYm9vdHN0cmFwXCIgaXMgcmVxdWlyZWQpJyk7XG4gIH1cblxuICBjb25zdCB0ZW1wbGF0ZUhhc2ggPSBjb250ZW50SGFzaCh0ZW1wbGF0ZUpzb24pO1xuICBjb25zdCBrZXkgPSBgY2RrLyR7c3RhY2suaWR9LyR7dGVtcGxhdGVIYXNofS55bWxgO1xuXG4gIGxldCB0ZW1wbGF0ZUZpbGUgPSBzdGFjay50ZW1wbGF0ZUZpbGU7XG4gIGlmIChvdmVycmlkZVRlbXBsYXRlKSB7XG4gICAgLy8gQWRkIGEgdmFyaWFudCBvZiB0aGlzIHRlbXBsYXRlXG4gICAgdGVtcGxhdGVGaWxlID0gYCR7c3RhY2sudGVtcGxhdGVGaWxlfS0ke3RlbXBsYXRlSGFzaH0ueWFtbGA7XG4gICAgYXdhaXQgZnMud3JpdGVGaWxlKHRlbXBsYXRlRmlsZSwgdGVtcGxhdGVKc29uLCB7IGVuY29kaW5nOiAndXRmLTgnIH0pO1xuICB9XG5cbiAgYXNzZXRNYW5pZmVzdC5hZGRGaWxlQXNzZXQodGVtcGxhdGVIYXNoLCB7XG4gICAgcGF0aDogdGVtcGxhdGVGaWxlLFxuICB9LCB7XG4gICAgYnVja2V0TmFtZTogdG9vbGtpdEluZm8uYnVja2V0TmFtZSxcbiAgICBvYmplY3RLZXk6IGtleSxcbiAgfSk7XG5cbiAgY29uc3QgdGVtcGxhdGVVUkwgPSBgJHt0b29sa2l0SW5mby5idWNrZXRVcmx9LyR7a2V5fWA7XG4gIGRlYnVnKCdTdG9yaW5nIHRlbXBsYXRlIGluIFMzIGF0OicsIHRlbXBsYXRlVVJMKTtcbiAgcmV0dXJuIHsgVGVtcGxhdGVVUkw6IHRlbXBsYXRlVVJMIH07XG59XG5cbi8qKlxuICogUHJlcGFyZSBhIGJvZHkgcGFyYW1ldGVyIGZvciBDRk4sIHBlcmZvcm1pbmcgdGhlIHVwbG9hZFxuICpcbiAqIFJldHVybiBpdCBhcy1pcyBpZiBpdCBpcyBzbWFsbCBlbm91Z2ggdG8gcGFzcyBpbiB0aGUgQVBJIGNhbGwsXG4gKiB1cGxvYWQgdG8gUzMgYW5kIHJldHVybiB0aGUgY29vcmRpbmF0ZXMgaWYgaXQgaXMgbm90LlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbWFrZUJvZHlQYXJhbWV0ZXJBbmRVcGxvYWQoXG4gIHN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3QsXG4gIHJlc29sdmVkRW52aXJvbm1lbnQ6IGN4YXBpLkVudmlyb25tZW50LFxuICB0b29sa2l0SW5mbzogVG9vbGtpdEluZm8sXG4gIHNka1Byb3ZpZGVyOiBTZGtQcm92aWRlcixcbiAgc2RrOiBJU0RLLFxuICBvdmVycmlkZVRlbXBsYXRlPzogYW55KTogUHJvbWlzZTxUZW1wbGF0ZUJvZHlQYXJhbWV0ZXI+IHtcblxuICAvLyBXZSBkb24ndCBoYXZlIGFjY2VzcyB0byB0aGUgYWN0dWFsIGFzc2V0IG1hbmlmZXN0IGhlcmUsIHNvIHByZXRlbmQgdGhhdCB0aGVcbiAgLy8gc3RhY2sgZG9lc24ndCBoYXZlIGEgcHJlLXB1Ymxpc2hlZCBVUkwuXG4gIGNvbnN0IGZvcmNlVXBsb2FkU3RhY2sgPSBPYmplY3QuY3JlYXRlKHN0YWNrLCB7XG4gICAgc3RhY2tUZW1wbGF0ZUFzc2V0T2JqZWN0VXJsOiB7IHZhbHVlOiB1bmRlZmluZWQgfSxcbiAgfSk7XG5cbiAgY29uc3QgYnVpbGRlciA9IG5ldyBBc3NldE1hbmlmZXN0QnVpbGRlcigpO1xuICBjb25zdCBib2R5cGFyYW0gPSBhd2FpdCBtYWtlQm9keVBhcmFtZXRlcihmb3JjZVVwbG9hZFN0YWNrLCByZXNvbHZlZEVudmlyb25tZW50LCBidWlsZGVyLCB0b29sa2l0SW5mbywgc2RrLCBvdmVycmlkZVRlbXBsYXRlKTtcbiAgY29uc3QgbWFuaWZlc3QgPSBidWlsZGVyLnRvTWFuaWZlc3Qoc3RhY2suYXNzZW1ibHkuZGlyZWN0b3J5KTtcbiAgYXdhaXQgcHVibGlzaEFzc2V0cyhtYW5pZmVzdCwgc2RrUHJvdmlkZXIsIHJlc29sdmVkRW52aXJvbm1lbnQsIHsgcXVpZXQ6IHRydWUgfSk7XG4gIHJldHVybiBib2R5cGFyYW07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVzdHJveVN0YWNrT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgc3RhY2sgdG8gYmUgZGVzdHJveWVkXG4gICAqL1xuICBzdGFjazogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0O1xuXG4gIHNkazogSVNESztcbiAgcm9sZUFybj86IHN0cmluZztcbiAgZGVwbG95TmFtZT86IHN0cmluZztcbiAgcXVpZXQ/OiBib29sZWFuO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVzdHJveVN0YWNrKG9wdGlvbnM6IERlc3Ryb3lTdGFja09wdGlvbnMpIHtcbiAgY29uc3QgZGVwbG95TmFtZSA9IG9wdGlvbnMuZGVwbG95TmFtZSB8fCBvcHRpb25zLnN0YWNrLnN0YWNrTmFtZTtcbiAgY29uc3QgY2ZuID0gb3B0aW9ucy5zZGsuY2xvdWRGb3JtYXRpb24oKTtcblxuICBjb25zdCBjdXJyZW50U3RhY2sgPSBhd2FpdCBDbG91ZEZvcm1hdGlvblN0YWNrLmxvb2t1cChjZm4sIGRlcGxveU5hbWUpO1xuICBpZiAoIWN1cnJlbnRTdGFjay5leGlzdHMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbW9uaXRvciA9IG9wdGlvbnMucXVpZXQgPyB1bmRlZmluZWQgOiBTdGFja0FjdGl2aXR5TW9uaXRvci53aXRoRGVmYXVsdFByaW50ZXIoY2ZuLCBkZXBsb3lOYW1lLCBvcHRpb25zLnN0YWNrKS5zdGFydCgpO1xuXG4gIHRyeSB7XG4gICAgYXdhaXQgY2ZuLmRlbGV0ZVN0YWNrKHsgU3RhY2tOYW1lOiBkZXBsb3lOYW1lLCBSb2xlQVJOOiBvcHRpb25zLnJvbGVBcm4gfSkucHJvbWlzZSgpO1xuICAgIGNvbnN0IGRlc3Ryb3llZFN0YWNrID0gYXdhaXQgd2FpdEZvclN0YWNrRGVsZXRlKGNmbiwgZGVwbG95TmFtZSk7XG4gICAgaWYgKGRlc3Ryb3llZFN0YWNrICYmIGRlc3Ryb3llZFN0YWNrLnN0YWNrU3RhdHVzLm5hbWUgIT09ICdERUxFVEVfQ09NUExFVEUnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBkZXN0cm95ICR7ZGVwbG95TmFtZX06ICR7ZGVzdHJveWVkU3RhY2suc3RhY2tTdGF0dXN9YCk7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGlmIChtb25pdG9yKSB7IGF3YWl0IG1vbml0b3Iuc3RvcCgpOyB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB3ZSBjYW4gc2tpcCBkZXBsb3ltZW50XG4gKlxuICogV2UgZG8gdGhpcyBpbiBhIGNvbXBsaWNhdGVkIHdheSBieSBwcmVwcm9jZXNzaW5nIChpbnN0ZWFkIG9mIGp1c3RcbiAqIGxvb2tpbmcgYXQgdGhlIGNoYW5nZXNldCksIGJlY2F1c2UgaWYgdGhlcmUgYXJlIG5lc3RlZCBzdGFja3MgaW52b2x2ZWRcbiAqIHRoZSBjaGFuZ2VzZXQgd2lsbCBhbHdheXMgc2hvdyB0aGUgbmVzdGVkIHN0YWNrcyBhcyBuZWVkaW5nIHRvIGJlXG4gKiB1cGRhdGVkLCBhbmQgdGhlIGRlcGxveW1lbnQgd2lsbCB0YWtlIGEgbG9uZyB0aW1lIHRvIGluIGVmZmVjdCBub3RcbiAqIGRvIGFueXRoaW5nLlxuICovXG5hc3luYyBmdW5jdGlvbiBjYW5Ta2lwRGVwbG95KFxuICBkZXBsb3lTdGFja09wdGlvbnM6IERlcGxveVN0YWNrT3B0aW9ucyxcbiAgY2xvdWRGb3JtYXRpb25TdGFjazogQ2xvdWRGb3JtYXRpb25TdGFjayxcbiAgcGFyYW1ldGVyQ2hhbmdlczogUGFyYW1ldGVyQ2hhbmdlcyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuXG4gIGNvbnN0IGRlcGxveU5hbWUgPSBkZXBsb3lTdGFja09wdGlvbnMuZGVwbG95TmFtZSB8fCBkZXBsb3lTdGFja09wdGlvbnMuc3RhY2suc3RhY2tOYW1lO1xuICBkZWJ1ZyhgJHtkZXBsb3lOYW1lfTogY2hlY2tpbmcgaWYgd2UgY2FuIHNraXAgZGVwbG95YCk7XG5cbiAgLy8gRm9yY2VkIGRlcGxveVxuICBpZiAoZGVwbG95U3RhY2tPcHRpb25zLmZvcmNlKSB7XG4gICAgZGVidWcoYCR7ZGVwbG95TmFtZX06IGZvcmNlZCBkZXBsb3ltZW50YCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gQ3JlYXRpbmcgY2hhbmdlc2V0IG9ubHkgKGRlZmF1bHQgdHJ1ZSksIG5ldmVyIHNraXBcbiAgaWYgKGRlcGxveVN0YWNrT3B0aW9ucy5leGVjdXRlID09PSBmYWxzZSkge1xuICAgIGRlYnVnKGAke2RlcGxveU5hbWV9OiAtLW5vLWV4ZWN1dGUsIGFsd2F5cyBjcmVhdGluZyBjaGFuZ2Ugc2V0YCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gTm8gZXhpc3Rpbmcgc3RhY2tcbiAgaWYgKCFjbG91ZEZvcm1hdGlvblN0YWNrLmV4aXN0cykge1xuICAgIGRlYnVnKGAke2RlcGxveU5hbWV9OiBubyBleGlzdGluZyBzdGFja2ApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRlbXBsYXRlIGhhcyBjaGFuZ2VkIChhc3NldHMgdGFrZW4gaW50byBhY2NvdW50IGhlcmUpXG4gIGlmIChKU09OLnN0cmluZ2lmeShkZXBsb3lTdGFja09wdGlvbnMuc3RhY2sudGVtcGxhdGUpICE9PSBKU09OLnN0cmluZ2lmeShhd2FpdCBjbG91ZEZvcm1hdGlvblN0YWNrLnRlbXBsYXRlKCkpKSB7XG4gICAgZGVidWcoYCR7ZGVwbG95TmFtZX06IHRlbXBsYXRlIGhhcyBjaGFuZ2VkYCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVGFncyBoYXZlIGNoYW5nZWRcbiAgaWYgKCFjb21wYXJlVGFncyhjbG91ZEZvcm1hdGlvblN0YWNrLnRhZ3MsIGRlcGxveVN0YWNrT3B0aW9ucy50YWdzID8/IFtdKSkge1xuICAgIGRlYnVnKGAke2RlcGxveU5hbWV9OiB0YWdzIGhhdmUgY2hhbmdlZGApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRlcm1pbmF0aW9uIHByb3RlY3Rpb24gaGFzIGJlZW4gdXBkYXRlZFxuICBpZiAoISFkZXBsb3lTdGFja09wdGlvbnMuc3RhY2sudGVybWluYXRpb25Qcm90ZWN0aW9uICE9PSAhIWNsb3VkRm9ybWF0aW9uU3RhY2sudGVybWluYXRpb25Qcm90ZWN0aW9uKSB7XG4gICAgZGVidWcoYCR7ZGVwbG95TmFtZX06IHRlcm1pbmF0aW9uIHByb3RlY3Rpb24gaGFzIGJlZW4gdXBkYXRlZGApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFBhcmFtZXRlcnMgaGF2ZSBjaGFuZ2VkXG4gIGlmIChwYXJhbWV0ZXJDaGFuZ2VzKSB7XG4gICAgaWYgKHBhcmFtZXRlckNoYW5nZXMgPT09ICdzc20nKSB7XG4gICAgICBkZWJ1ZyhgJHtkZXBsb3lOYW1lfTogc29tZSBwYXJhbWV0ZXJzIGNvbWUgZnJvbSBTU00gc28gd2UgaGF2ZSB0byBhc3N1bWUgdGhleSBtYXkgaGF2ZSBjaGFuZ2VkYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKGAke2RlcGxveU5hbWV9OiBwYXJhbWV0ZXJzIGhhdmUgY2hhbmdlZGApO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFeGlzdGluZyBzdGFjayBpcyBpbiBhIGZhaWxlZCBzdGF0ZVxuICBpZiAoY2xvdWRGb3JtYXRpb25TdGFjay5zdGFja1N0YXR1cy5pc0ZhaWx1cmUpIHtcbiAgICBkZWJ1ZyhgJHtkZXBsb3lOYW1lfTogc3RhY2sgaXMgaW4gYSBmYWlsdXJlIHN0YXRlYCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gV2UgY2FuIHNraXAgZGVwbG95XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIENvbXBhcmVzIHR3byBsaXN0IG9mIHRhZ3MsIHJldHVybnMgdHJ1ZSBpZiBpZGVudGljYWwuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVUYWdzKGE6IFRhZ1tdLCBiOiBUYWdbXSk6IGJvb2xlYW4ge1xuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChjb25zdCBhVGFnIG9mIGEpIHtcbiAgICBjb25zdCBiVGFnID0gYi5maW5kKHRhZyA9PiB0YWcuS2V5ID09PSBhVGFnLktleSk7XG5cbiAgICBpZiAoIWJUYWcgfHwgYlRhZy5WYWx1ZSAhPT0gYVRhZy5WYWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEZvcm1hdCBhbiBTMyBVUkwgaW4gdGhlIG1hbmlmZXN0IGZvciB1c2Ugd2l0aCBDbG91ZEZvcm1hdGlvblxuICpcbiAqIFJlcGxhY2VzIGVudmlyb25tZW50IHBsYWNlaG9sZGVycyAod2hpY2ggdGhpcyBmaWVsZCBtYXkgY29udGFpbiksXG4gKiBhbmQgcmVmb3JtYXRzIHMzOi8vLi4uLy4uLiB1cmxzIGludG8gUzMgUkVTVCBVUkxzICh3aGljaCBDbG91ZEZvcm1hdGlvblxuICogZXhwZWN0cylcbiAqL1xuZnVuY3Rpb24gcmVzdFVybEZyb21NYW5pZmVzdCh1cmw6IHN0cmluZywgZW52aXJvbm1lbnQ6IGN4YXBpLkVudmlyb25tZW50LCBzZGs6IElTREspOiBzdHJpbmcge1xuICBjb25zdCBkb05vdFVzZU1hcmtlciA9ICcqKkRPTk9UVVNFKionO1xuICAvLyBUaGlzIFVSTCBtYXkgY29udGFpbiBwbGFjZWhvbGRlcnMsIHNvIHN0aWxsIHN1YnN0aXR1dGUgdGhvc2UuXG4gIHVybCA9IGN4YXBpLkVudmlyb25tZW50UGxhY2Vob2xkZXJzLnJlcGxhY2UodXJsLCB7XG4gICAgYWNjb3VudElkOiBlbnZpcm9ubWVudC5hY2NvdW50LFxuICAgIHJlZ2lvbjogZW52aXJvbm1lbnQucmVnaW9uLFxuICAgIHBhcnRpdGlvbjogZG9Ob3RVc2VNYXJrZXIsXG4gIH0pO1xuXG4gIC8vIFllcywgdGhpcyBpcyBleHRyZW1lbHkgY3J1ZGUsIGJ1dCB3ZSBkb24ndCBhY3R1YWxseSBuZWVkIHRoaXMgc28gSSdtIG5vdCBpbmNsaW5lZCB0byBzcGVuZFxuICAvLyBhIGxvdCBvZiBlZmZvcnQgdHJ5aW5nIHRvIHRocmVhZCB0aGUgcmlnaHQgdmFsdWUgdG8gdGhpcyBsb2NhdGlvbi5cbiAgaWYgKHVybC5pbmRleE9mKGRvTm90VXNlTWFya2VyKSA+IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXNlIFxcJyR7QVdTOjpQYXJ0aXRpb259XFwnIGluIHRoZSBcXCdzdGFja1RlbXBsYXRlQXNzZXRPYmplY3RVcmxcXCcgZmllbGQnKTtcbiAgfVxuXG4gIGNvbnN0IHMzVXJsID0gdXJsLm1hdGNoKC9zMzpcXC9cXC8oW14vXSspXFwvKC4qKSQvKTtcbiAgaWYgKCFzM1VybCkgeyByZXR1cm4gdXJsOyB9XG5cbiAgLy8gV2UgbmVlZCB0byBwYXNzIGFuICdodHRwczovL3MzLlJFR0lPTi5hbWF6b25hd3MuY29tWy5jbl0vYnVja2V0L29iamVjdCcgVVJMIHRvIENsb3VkRm9ybWF0aW9uLCBidXQgd2VcbiAgLy8gZ290IGFuICdzMzovL2J1Y2tldC9vYmplY3QnIFVSTCBpbnN0ZWFkLiBDb25zdHJ1Y3QgdGhlIHJlc3QgQVBJIFVSTCBoZXJlLlxuICBjb25zdCBidWNrZXROYW1lID0gczNVcmxbMV07XG4gIGNvbnN0IG9iamVjdEtleSA9IHMzVXJsWzJdO1xuXG4gIGNvbnN0IHVybFN1ZmZpeDogc3RyaW5nID0gc2RrLmdldEVuZHBvaW50U3VmZml4KGVudmlyb25tZW50LnJlZ2lvbik7XG4gIHJldHVybiBgaHR0cHM6Ly9zMy4ke2Vudmlyb25tZW50LnJlZ2lvbn0uJHt1cmxTdWZmaXh9LyR7YnVja2V0TmFtZX0vJHtvYmplY3RLZXl9YDtcbn1cbiJdfQ==